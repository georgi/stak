#!/usr/bin/env bash
# stak — minimal stacked-PR manager for single-commit branches
#
# PURPOSE
#   Keep a stack of single-commit branches in sync, similar in spirit to
#   ghstack/graphite, but as one simple Bash command:
#
#     stak sync --top <top-branch> [--base <base-branch>] [--remote <name>]
#
#   The stack is interpreted as: BASE -> b1 -> b2 -> ... -> top.
#   Each branch MUST be exactly one commit ahead of its parent.
#
# WHAT IT DOES
#   1) Ensures a clean working tree.
#   2) Resolves REMOTE and BASE.
#   3) Determines stack order (auto from --top).
#   4) Validates one-commit invariant between links in the chain.
#   5) Iteratively: checkout child, cherry-pick tip onto parent, push --force-with-lease.
#
# SCOPE & NON-GOALS
#   - Does NOT create PRs or modify titles/bodies/labels.
#   - Does NOT “magically” recover if your branches contain multiple commits.
#   - Stops on conflicts (fix, then re-run).
#
# USAGE
#   Show help:
#       stak --help
#
#   Sync by auto-detecting the chain from the top branch:
#       stak sync --top feat/audit
#
#   Specify base & remote explicitly:
#       stak sync --top feat/audit --base main --remote origin
#
#   Dry-run (prints actions only):
#       stak sync --top feat/audit --dry-run
#
# EXIT CODES
#   0 on success; non-zero on error (e.g., dirty tree, validation failure).
#
# REQUIREMENTS
#   - bash 4+ (arrays, associative arrays)
#   - git 2.20+ (for --force-with-lease and modern plumbing)
#
# SAFETY
#   - Uses `--force-with-lease` rather than raw `--force`.
#   - Verifies clean worktree before making changes.
#
# Copyright
#   Public domain / CC0. Use at your own risk.

set -Eeuo pipefail
IFS=$'\n\t'

###############################################################################
# Logging & Utilities
###############################################################################

# log_info: Print a normal informational message to stdout.
# Arguments:
#   $*  - message parts
log_info() { printf '==> %s\n' "$*"; }

# log_warn: Print a warning to stderr.
# Arguments:
#   $*  - message parts
log_warn() { printf 'warning: %s\n' "$*" >&2; }

# log_err: Print an error to stderr and exit non-zero.
# Arguments:
#   $*  - message parts
log_err() { printf 'error: %s\n' "$*" >&2; exit 1; }

# run: Execute a command or echo in dry-run mode.
# Globals:
#   DRYRUN (0|1)
# Arguments:
#   $*  - command to run
run() {
  if [[ "${DRYRUN:-0}" -eq 1 ]]; then
    printf '[dry-run] %s\n' "$*"
  else
    eval "$@"
  fi
}

# print_conflicted_files: Print a short list of currently conflicted paths, if any.
print_conflicted_files() {
  local files
  files="$(git diff --name-only --diff-filter=U || true)"
  if [[ -n "$files" ]]; then
    log_warn "Conflicted files:"
    printf '%s\n' "$files" >&2
  fi
}

# ensure_bin: Verify a binary exists in PATH.
# Arguments:
#   $1 - binary name
ensure_bin() {
  command -v "$1" >/dev/null 2>&1 || log_err "Required binary not found: $1"
}

# git_root: Print repository root. Exits if not in a git repo.
git_root() {
  git rev-parse --show-toplevel 2>/dev/null || log_err "Not a git repository."
}

###############################################################################
# State Management (for resumable cherry-picks)
###############################################################################

# State file format (.git/stak-state)
# -----------------------------------
# This file records stack configuration and, when a cherry-pick halts, progress.
# It is a simple, line-based KEY=VALUE file with no quoting or escaping.
# Unknown keys are ignored for forward-compatibility.
#
# Keys:
#   BASE      : Base branch name
#   REMOTE    : Remote name
#   ORDERED   : Comma-separated list of branches in bottom->top order
#   INDEX     : Zero-based index into ORDERED of the branch currently being rebased
#   CURRENT   : Convenience copy of ORDERED[INDEX]
#   DRYRUN    : 0|1 flag recorded for information only; does not affect behavior on resume
#
# Lifecycles:
#   - Persistent stack (written after successful sync/restack):
#       BASE, REMOTE, ORDERED
#   - In-progress cherry-pick (written when a cherry-pick stops on conflicts):
#       BASE, REMOTE, ORDERED, INDEX, CURRENT, DRYRUN
#
# Removal:
#   - The file is removed by clear_state() and after a successful 'stak continue'.
#
# state_file: Return path to the stak state file inside .git/
state_file() {
  git rev-parse --git-path stak-state
}

# save_state: Persist current progress for resumable workflow.
# Arguments:
#   $1 - base branch
#   $2 - remote name
#   $3 - ordered branches as CSV (bottom->top)
#   $4 - current index (0-based) in ORDERED
#   $5 - current branch name (ORDERED[$4])
# save_state: Persist in-progress rebase state (includes progress markers).
# Arguments:
#   $1 base, $2 remote, $3 ordered_csv, $4 index (0-based), $5 current branch
save_state() {
  local base="$1" remote="$2" ordered_csv="$3" index="$4" current="$5"
  local f
  f="$(state_file)"
  {
    printf 'BASE=%s\n' "$base"
    printf 'REMOTE=%s\n' "$remote"
    printf 'ORDERED=%s\n' "$ordered_csv"
    printf 'INDEX=%s\n' "$index"
    printf 'CURRENT=%s\n' "$current"
    printf 'DRYRUN=%s\n' "${DRYRUN:-0}"
  } >"$f"
}

# load_state: Source state into environment. Fails if missing.
load_state() {
  local f key val line
  f="$(state_file)"
  [[ -f "$f" ]] || log_err "No stak state found. Nothing to continue."
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip empty or comment lines
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    key="${line%%=*}"
    val="${line#*=}"
    case "$key" in
      BASE)       BASE="$val" ;;
      REMOTE)     REMOTE="$val" ;;
      ORDERED)    ORDERED="$val" ;;
      INDEX)      INDEX="$val" ;;
      CURRENT)    CURRENT="$val" ;;
      DRYRUN)     DRYRUN="$val" ;;
      *) ;; # ignore unknown keys
    esac
  done < "$f"
}

# clear_state: Remove state file if present.
clear_state() {
  local f
  f="$(state_file)"
  [[ -f "$f" ]] && rm -f "$f" || true
}

# rebase_in_progress: Return 0 if a git rebase is currently in progress.
rebase_in_progress() {
  local m a
  m="$(git rev-parse --git-path rebase-merge)"
  a="$(git rev-parse --git-path rebase-apply)"
  [[ -d "$m" || -d "$a" ]]
}

# cherry_pick_in_progress: Return 0 if a git cherry-pick is currently in progress.
cherry_pick_in_progress() {
  local head sequencer
  head="$(git rev-parse --git-path CHERRY_PICK_HEAD)"
  sequencer="$(git rev-parse --git-path sequencer)"
  [[ -f "$head" || -d "$sequencer" ]]
}

# write_stack_state: Persist only stable stack info (no progress fields).
# Arguments: $1 base, $2 remote, $3 ordered_csv
write_stack_state() {
  local base="$1" remote="$2" ordered_csv="$3" f
  f="$(state_file)"
  {
    printf 'BASE=%s\n' "$base"
    printf 'REMOTE=%s\n' "$remote"
    printf 'ORDERED=%s\n' "$ordered_csv"
  } >"$f"
}

###############################################################################
# Git Helpers
###############################################################################

# ensure_clean_worktree: Fail if there are staged or unstaged changes.
ensure_clean_worktree() {
  if ! git diff --quiet || ! git diff --cached --quiet; then
    log_err "Working tree not clean. Commit or stash changes first."
  fi
}

# default_remote: Determine the default remote name.
#   Priority:
#     1) 'origin' if present
#     2) first remote in `git remote`
# Returns:
#   prints remote name
default_remote() {
  if git remote | grep -qx 'origin'; then
    echo "origin"
    return
  fi
  local first
  first="$(git remote | head -n1 || true)"
  [[ -n "$first" ]] || log_err "No remotes found. Add one (e.g., 'origin')."
  echo "$first"
}

# default_base_branch: Determine the default base branch.
#   Priority:
#     1) symbolic remote HEAD (e.g., origin/HEAD -> origin/main)
#     2) first existing among: main, trunk, master, develop
# Arguments:
#   $1 - remote name
# Returns:
#   prints base branch name
default_base_branch() {
  local remote="$1" head_ref base
  head_ref="$(git symbolic-ref -q --short "refs/remotes/${remote}/HEAD" || true)"
  if [[ -n "$head_ref" ]]; then
    base="${head_ref#${remote}/}"
    echo "$base"
    return
  fi
  for cand in main trunk master develop; do
    if git ls-remote --exit-code --heads "$remote" "$cand" >/dev/null 2>&1; then
      echo "$cand"
      return
    fi
  done
  log_err "Could not determine base branch. Specify with --base."
}

# ensure_branch_local: Ensure a local branch exists; create from remote if needed.
# Arguments:
#   $1 - branch name
#   $2 - remote name
ensure_branch_local() {
  local b="$1" remote="$2"
  if ! git show-ref --verify --quiet "refs/heads/$b"; then
    if git ls-remote --heads "$remote" "$b" >/dev/null 2>&1; then
      log_info "Creating local branch '$b' from ${remote}/${b}"
      run "git fetch ${remote} ${b}:${b}"
    else
      log_err "Branch '$b' not found locally or on remote '${remote}'."
    fi
  fi
}

# is_ancestor: True if $1 is ancestor of $2.
# Arguments:
#   $1 - ancestor commit
#   $2 - descendant commit
is_ancestor() {
  git merge-base --is-ancestor "$1" "$2"
}

# branch_tip: Print the commit sha of a branch tip.
# Arguments:
#   $1 - branch name
branch_tip() {
  git rev-parse "$1^{commit}"
}

# parent_of_tip: Print the parent commit sha of a branch tip (single-parent).
# Arguments:
#   $1 - branch name
parent_of_tip() {
  git rev-parse "$1^" 2>/dev/null || log_err "Branch '$1' has no parent (root commit?)."
}

# commits_ahead: Count commits in range A..B (commits in B not in A).
# Arguments:
#   $1 - A
#   $2 - B
commits_ahead() {
  git rev-list --count "${1}..${2}"
}

###############################################################################
# Stack Resolution
###############################################################################

# build_commit_to_branch_map: Populate an associative map of commit tip -> branch.
# Populates:
#   HEAD_BY_COMMIT[<sha>] = <branch-name>
# Arguments:
#   $1 - remote name
# Globals:
#   declare -gA HEAD_BY_COMMIT
build_commit_to_branch_map() {
  declare -gA HEAD_BY_COMMIT=()
  # Remote heads
  while IFS=$'\t' read -r sha ref; do
    [[ -n "$sha" && -n "$ref" ]] || continue
    local name="${ref#refs/heads/}"
    HEAD_BY_COMMIT["$sha"]="$name"
  done < <(git ls-remote --heads "$1")
  # Local heads
  while read -r sha ref; do
    local name="${ref#refs/heads/}"
    HEAD_BY_COMMIT["$sha"]="$name"
  done < <(git for-each-ref --format='%(objectname) %(refname)' refs/heads/)
}

# auto_stack_from_top: Determine stack (bottom->top) by walking parents from top.
#   For single-commit branches, the parent of a branch tip SHOULD be the tip
#   of its parent branch (or an ancestor reachable from BASE). We walk:
#     top -> parent tip -> find matching branch name -> repeat
#   until the parent is in BASE history.
# Arguments:
#   $1 - top branch
#   $2 - base branch
#   $3 - remote name
# Outputs:
#   prints space-separated branch list in bottom->top order
auto_stack_from_top() {
  local top="$1" base="$2" remote="$3"
  ensure_branch_local "$top" "$remote"
  ensure_branch_local "$base" "$remote"

  build_commit_to_branch_map "$remote"

  local chain=("$top")
  local cur="$top"

  while true; do
    local parent_sha
    parent_sha="$(parent_of_tip "$cur")"

    # If the parent is already contained in BASE, we reached the bottom.
    if is_ancestor "$parent_sha" "$base"; then
      break
    fi

    local parent_branch="${HEAD_BY_COMMIT[$parent_sha]:-}"
    [[ -n "$parent_branch" ]] || log_err \
      "Could not find a branch whose tip equals parent of '$cur' ($parent_sha).
       Ensure each branch is exactly ONE commit on top of its parent and all branches exist."

    chain+=("$parent_branch")
    cur="$parent_branch"
  done

  # chain is top->...->bottom; reverse to bottom->top
  local n=${#chain[@]} i
  local out=()
  for ((i=n-1; i>=0; i--)); do out+=("${chain[$i]}"); done

  printf '%s\n' "${out[*]}"
}

# validate_single_commit_chain: Ensure every branch is exactly one commit ahead.
# Arguments:
#   $1   - base branch
#   $@2+ - ordered branches (bottom->top)
validate_single_commit_chain() {
  local base="$1"; shift
  local prev="$base"
  local b count
  for b in "$@"; do
    count="$(commits_ahead "$prev" "$b")"
    if [[ "$count" -ne 1 ]]; then
      log_err "Validation failed: '$b' must be EXACTLY one commit ahead of its parent '$prev' (found $count)."
    fi
    prev="$b"
  done
}

###############################################################################
# Sync (Rebase & Push)
###############################################################################

# ensure_upstream_if_missing: Ensure a branch has an upstream; set or push -u.
# Arguments:
#   $1 - branch name
#   $2 - remote name
ensure_upstream_if_missing() {
  local b="$1" remote="$2"
  if ! git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1; then
    # Try to set upstream to remote/<branch>; if it doesn't exist, push -u.
    if git ls-remote --heads "$remote" "$b" >/dev/null 2>&1; then
      run "git branch --set-upstream-to=${remote}/${b} ${b}"
    else
      run "git push -u ${remote} ${b}"
    fi
  fi
}

# rebase_and_push_stack: For each branch, cherry-pick tip onto parent and push with lease.
# Arguments:
#   $1   - base branch
#   $2   - remote name
#   $@3+ - ordered branches (bottom->top)
rebase_and_push_stack() {
  local base="$1" remote="$2"; shift 2
  local branches=("$@")
  local prev="$base" b idx ordered_csv tip

  # Compute CSV for state persistence
  ordered_csv="$(IFS=,; echo "${branches[*]}")"

  for idx in "${!branches[@]}"; do
    b="${branches[$idx]}"
    run "git checkout ${b}"
    tip="$(branch_tip "$b")"
    # If already based on prev, skip
    local current_parent prev_sha
    current_parent="$(parent_of_tip "$b")"
    prev_sha="$(branch_tip "$prev")"
    if [[ "$current_parent" == "$prev_sha" ]]; then
      log_info "'${b}' already based on '${prev}'. Skipping."
      log_info "Pushing '${b}' to ${remote} (force-with-lease)"
      ensure_upstream_if_missing "$b" "$remote"
      run "git push --force-with-lease ${remote} HEAD:refs/heads/${b}"
      prev="$b"
      continue
    fi

    log_info "Cherry-picking tip of '${b}' onto '${prev}'"
    if [[ "${DRYRUN:-0}" -eq 1 ]]; then
      printf '[dry-run] git reset --hard %s\n' "$prev"
      printf '[dry-run] git cherry-pick %s\n' "$tip"
    else
      if ! git reset --hard "$prev"; then
        save_state "$base" "$remote" "$ordered_csv" "$idx" "$b"
        log_warn "Failed to reset '${b}' to '${prev}'. Resolve issues, then run: stak continue"
        print_conflicted_files
        exit 2
      fi
      if ! git cherry-pick "$tip"; then
        save_state "$base" "$remote" "$ordered_csv" "$idx" "$b"
        log_warn "Cherry-pick stopped due to conflicts on '${b}'."
        log_warn "Resolve conflicts, then run: stak continue"
        print_conflicted_files
        exit 2
      fi
    fi

    log_info "Pushing '${b}' to ${remote} (force-with-lease)"
    ensure_upstream_if_missing "$b" "$remote"
    run "git push --force-with-lease ${remote} HEAD:refs/heads/${b}"

    prev="$b"
  done
}

###############################################################################
# CLI Parsing & Main
###############################################################################

print_help() {
  cat <<'EOF'
stak — minimal stacked-PR manager for single-commit branches

USAGE
  stak sync --top <top-branch> [--base <base-branch>] [--remote <name>] [--dry-run]
  stak restack --branches <b1,b2,...> [--base <base-branch>] [--remote <name>] [--dry-run]
  stak continue

DESCRIPTION
  Sync (cherry-pick & push) a stack of branches where each branch is a single commit.
  The stack is interpreted as: BASE -> b1 -> b2 -> ... -> top.

OPTIONS
  --top <branch>        Auto-detect bottom->top chain by walking parents from <branch>.
  --base <branch>       Base branch (defaults to remote HEAD or main/trunk/master/develop).
  --remote <name>       Remote name (default: origin).
  --dry-run             Print actions without executing them.
  # interactive mode is not applicable for cherry-pick; option is accepted but ignored.
  --branches <csv>      For 'restack': explicit chain in bottom->top order (e.g., A,B,C,D).
  -h, --help            Show this help.

EXAMPLES
  stak sync --top feat/audit
  stak sync --top feat/audit --base main --remote origin --dry-run
  stak restack --branches A,B,C,D --base main --remote origin
  stak continue   # after resolving conflicts, resume and finish the stack
EOF
}

# parse_args: Parse CLI into globals.
# Globals set:
#   CMD        - subcommand (currently only "sync")
#   TOP        - top branch (optional)
#   BASE       - base branch (optional)
#   REMOTE     - remote name (default resolved)
#   DRYRUN     - 0|1
parse_args() {
  CMD=""
  TOP=""
  BASE=""
  REMOTE=""
  DRYRUN=0
  BRANCHES_CSV=""
  INTERACTIVE=0

  [[ $# -gt 0 ]] || { print_help; exit 0; }

  case "${1:-}" in
    sync) CMD="sync"; shift ;;
    restack) CMD="restack"; shift ;;
    continue) CMD="continue"; shift ;;
    -h|--help) print_help; exit 0 ;;
    *) log_err "Unknown command: ${1}. Try --help." ;;
  esac

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --top) TOP="${2:-}"; [[ -n "$TOP" ]] || log_err "--top requires a value"; shift 2 ;;
      --base) BASE="${2:-}"; [[ -n "$BASE" ]] || log_err "--base requires a value"; shift 2 ;;
      --remote) REMOTE="${2:-}"; [[ -n "$REMOTE" ]] || log_err "--remote requires a value"; shift 2 ;;
      --dry-run) DRYRUN=1; shift ;;
      --interactive) INTERACTIVE=1; shift ;;
      --branches) BRANCHES_CSV="${2:-}"; [[ -n "$BRANCHES_CSV" ]] || log_err "--branches requires a comma-separated list"; shift 2 ;;
      -h|--help) print_help; exit 0 ;;
      *) log_err "Unknown option: $1" ;;
    esac
  done

  # Required: --top only for 'sync'
  if [[ "$CMD" == "sync" && -z "$TOP" ]]; then
    log_err "Missing required --top <branch>. See --help."
  fi
}

main_sync() {
  ensure_bin git
  git_root >/dev/null
  ensure_clean_worktree

  local remote base
  remote="${REMOTE:-$(default_remote)}"
  run "git fetch ${remote} --prune"

  if [[ -n "$BASE" ]]; then
    base="$BASE"
  else
    base="$(default_base_branch "$remote")"
  fi

  ensure_branch_local "$base" "$remote"

  local ordered=()
  if [[ -n "${TOP:-}" ]]; then
    ensure_branch_local "$TOP" "$remote"
    log_info "Auto-detecting stack from top '${TOP}' down to base '${base}'"
    # shellcheck disable=SC2207
    ordered=($(auto_stack_from_top "$TOP" "$base" "$remote"))
    [[ ${#ordered[@]} -gt 0 ]] || log_err "Auto-detection produced an empty stack."
  else
    # Try to load saved ORDERED from state file
    if [[ -f "$(state_file)" ]]; then
      load_state
      if [[ -n "${ORDERED:-}" ]]; then
        IFS=',' read -r -a ordered <<< "$ORDERED"
        log_info "Using saved stack from state: base '${BASE:-$base}' -> ${ordered[*]}"
        # If state had a different base/remote, prefer explicit CLI, else state
        [[ -n "${BASE:-}" ]] && base="$BASE"
        [[ -n "${REMOTE:-}" ]] && remote="$REMOTE"
      fi
    fi
    [[ ${#ordered[@]} -gt 0 ]] || log_err "No --top provided and no saved stack in state."
  fi

  log_info "Stack order: base '${base}' -> ${ordered[*]}"
  validate_single_commit_chain "$base" "${ordered[@]}"
  rebase_and_push_stack "$base" "$remote" "${ordered[@]}"
  # Save persistent stack info for future runs
  local ordered_csv
  ordered_csv="$(IFS=,; echo "${ordered[*]}")"
  write_stack_state "$base" "$remote" "$ordered_csv"
  log_info "Done."
}

main_restack() {
  ensure_bin git
  git_root >/dev/null
  ensure_clean_worktree

  local remote base
  remote="${REMOTE:-$(default_remote)}"
  run "git fetch ${remote} --prune"

  if [[ -n "$BASE" ]]; then
    base="$BASE"
  else
    base="$(default_base_branch "$remote")"
  fi

  ensure_branch_local "$base" "$remote"

  [[ -n "$BRANCHES_CSV" ]] || log_err "restack requires --branches <b1,b2,...> in bottom->top order"

  # Split CSV into array, trimming whitespace
  local csv_no_space
  csv_no_space="${BRANCHES_CSV//[[:space:]]/}"
  IFS=',' read -r -a ORDERED_BRANCHES <<< "$csv_no_space"

  [[ ${#ORDERED_BRANCHES[@]} -gt 0 ]] || log_err "No branches provided to --branches"

  # Ensure each branch exists locally (or fetch from remote)
  local b
  for b in "${ORDERED_BRANCHES[@]}"; do
    [[ -n "$b" ]] || continue
    ensure_branch_local "$b" "$remote"
  done

  log_info "Restacking explicit chain: base '${base}' -> ${ORDERED_BRANCHES[*]}"
  rebase_and_push_stack "$base" "$remote" "${ORDERED_BRANCHES[@]}"
  log_info "Done."
}

main_continue() {
  ensure_bin git
  git_root >/dev/null

  # Load state
  load_state

  # Expect variables from state: BASE, REMOTE, ORDERED, INDEX, CURRENT, DRYRUN
  local base remote ordered_csv index current seq_editor prev branches=()
  base="$BASE"
  remote="$REMOTE"
  ordered_csv="$ORDERED"
  index="$INDEX"
  current="$CURRENT"

  # Reconstruct branches array
  IFS=',' read -r -a branches <<< "$ordered_csv"

  # Determine previous branch (parent) for current index
  if [[ "$index" -eq 0 ]]; then
    prev="$base"
  else
    prev="${branches[$((index-1))]}"
  fi

  # Resume cherry-pick or legacy rebase
  if [[ "${DRYRUN:-0}" -eq 1 ]]; then
    printf '[dry-run] git cherry-pick --continue || git rebase --continue\n'
  else
    if cherry_pick_in_progress; then
      if ! git cherry-pick --continue; then
        log_warn "Cherry-pick still conflicted. Resolve conflicts, then run: stak continue"
        print_conflicted_files
        exit 2
      fi
    elif rebase_in_progress; then
      if ! git rebase --continue; then
        log_warn "Rebase still conflicted. Resolve conflicts, then run: stak continue"
        print_conflicted_files
        exit 2
      fi
    else
      # If no operation in progress (user may have already continued), proceed
      log_warn "No cherry-pick or rebase in progress. Continuing with remaining branches."
    fi
  fi

  # After successful rebase of CURRENT, push and continue remaining ones
  log_info "Pushing '${current}' to ${remote} (force-with-lease)"
  run "git checkout ${current}"
  ensure_upstream_if_missing "$current" "$remote"
  run "git push --force-with-lease ${remote} HEAD:refs/heads/${current}"

  # Continue with rest of branches after current index
  local next_index=$((index+1))
  if [[ ${#branches[@]} -gt $next_index ]]; then
    local rest=("${branches[@]:$next_index}")
    # Reuse the same interactive mode with default sequence editor.
    # IMPORTANT: subsequent branches must rebase onto the just-resolved 'current',
    # not onto the original 'base'.
    rebase_and_push_stack "$current" "$remote" "${rest[@]}"
  fi

  # Clear state on success
  clear_state
  log_info "Done."
}

main() {
  parse_args "$@"
  case "$CMD" in
    sync) main_sync ;;
    restack) main_restack ;;
    continue) main_continue ;;
    *) log_err "Unhandled command: $CMD" ;;
  esac
}

# Trap common signals to ensure clearer exit on interruptions.
trap 'log_warn "Interrupted."; exit 130' INT
trap 'log_warn "Terminated."; exit 143' TERM

main "$@"